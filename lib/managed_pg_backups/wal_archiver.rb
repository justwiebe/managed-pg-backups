# frozen_string_literal: true

require "fileutils"

module ManagedPgBackups
  class WalArchiver
    attr_reader :config, :storage

    def initialize(config, storage)
      @config = config
      @storage = storage
    end

    # Generate the archive_command string for postgresql.conf
    # This will be used by PostgreSQL to archive WAL segments
    def archive_command
      script_path = generate_archive_script
      "#{script_path} %p %f"
    end

    # Archive a WAL file (called by the archive script)
    def archive_wal_file(wal_path, wal_filename)
      remote_path = File.join("wal_archive", wal_filename)
      
      # Check if already archived (idempotent operation)
      if storage.exists?(remote_path)
        # Verify it's the same file
        return true
      end

      storage.upload(wal_path, remote_path)
      true
    rescue StandardError => e
      warn "Failed to archive WAL file #{wal_filename}: #{e.message}"
      false
    end

    # Generate the restore_command string for recovery.conf/postgresql.conf
    # This will be used by PostgreSQL during recovery to fetch WAL segments
    def restore_command
      script_path = generate_restore_script
      "#{script_path} %f %p"
    end

    # Restore a WAL file from archive (called by the restore script)
    def restore_wal_file(wal_filename, target_path)
      remote_path = File.join("wal_archive", wal_filename)
      
      unless storage.exists?(remote_path)
        # This is expected - PostgreSQL will request files that don't exist
        return false
      end

      storage.download(remote_path, target_path)
      true
    rescue StandardError => e
      warn "Failed to restore WAL file #{wal_filename}: #{e.message}"
      false
    end

    # List all archived WAL files
    def list_wal_files
      storage.list("wal_archive")
    end

    # Clean up WAL files older than the oldest backup we're keeping
    def cleanup_old_wal_files(oldest_wal_filename)
      list_wal_files.each do |wal_file|
        wal_name = File.basename(wal_file)
        if wal_name < oldest_wal_filename
          storage.delete(wal_file)
        end
      end
    end

    private

    def generate_archive_script
      script_dir = File.join(config.storage_path, "scripts")
      FileUtils.mkdir_p(script_dir)
      script_path = File.join(script_dir, "archive_wal.sh")

      script_content = <<~SCRIPT
        #!/bin/bash
        # Archive WAL file to storage
        # Generated by ManagedPgBackups
        
        WAL_PATH="$1"
        WAL_FILENAME="$2"
        
        # Call the Ruby gem to handle the actual archiving
        cd #{Dir.pwd}
        bundle exec ruby -e "
          require 'managed_pg_backups'
          config = ManagedPgBackups.configuration
          storage = ManagedPgBackups.storage
          archiver = ManagedPgBackups::WalArchiver.new(config, storage)
          exit(archiver.archive_wal_file('$WAL_PATH', '$WAL_FILENAME') ? 0 : 1)
        "
      SCRIPT

      File.write(script_path, script_content)
      FileUtils.chmod(0755, script_path)
      script_path
    end

    def generate_restore_script
      script_dir = File.join(config.storage_path, "scripts")
      FileUtils.mkdir_p(script_dir)
      script_path = File.join(script_dir, "restore_wal.sh")

      script_content = <<~SCRIPT
        #!/bin/bash
        # Restore WAL file from storage
        # Generated by ManagedPgBackups
        
        WAL_FILENAME="$1"
        TARGET_PATH="$2"
        
        # Call the Ruby gem to handle the actual restore
        cd #{Dir.pwd}
        bundle exec ruby -e "
          require 'managed_pg_backups'
          config = ManagedPgBackups.configuration
          storage = ManagedPgBackups.storage
          archiver = ManagedPgBackups::WalArchiver.new(config, storage)
          exit(archiver.restore_wal_file('$WAL_FILENAME', '$TARGET_PATH') ? 0 : 1)
        "
      SCRIPT

      File.write(script_path, script_content)
      FileUtils.chmod(0755, script_path)
      script_path
    end
  end
end
